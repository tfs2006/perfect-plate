# Netlify Functions - Copilot Instructions

## Purpose
This directory contains serverless functions that act as a secure proxy between the frontend and external APIs (primarily Google Gemini API).

## Security Architecture
- **No API Keys in Frontend**: All API keys are stored as Netlify environment variables
- **CORS Protection**: Functions implement strict CORS policies
- **Proxy Pattern**: Frontend never directly calls external APIs

## File Structure
- `generate-plan.js` - Main function that proxies Gemini API requests

## Function Handler Pattern

### Standard Handler Signature
```javascript
exports.handler = async (event) => {
  // CORS headers
  const cors = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Methods": "POST, OPTIONS",
    "Access-Control-Allow-Headers": "Content-Type, Authorization"
  };

  // OPTIONS request handling
  if (event.httpMethod === "OPTIONS") {
    return { statusCode: 204, headers: cors, body: "" };
  }

  // Method validation
  if (event.httpMethod !== "POST") {
    return { statusCode: 405, headers: cors, body: JSON.stringify({ error: "Method Not Allowed" }) };
  }

  // Main logic
  try {
    // Implementation
  } catch (err) {
    return { statusCode: 500, headers: cors, body: JSON.stringify({ error: err.message }) };
  }
};
```

## CORS Configuration

### Multi-Origin Support
```javascript
const originsEnv = process.env.ALLOWED_ORIGIN || "*";
const allowedList = originsEnv.split(",").map(s => s.trim()).filter(Boolean);
const reqOrigin = event.headers?.origin || event.headers?.Origin || "";

const allowOriginHeader = allowedList.includes("*")
  ? "*"
  : (reqOrigin && allowedList.includes(reqOrigin) ? reqOrigin : (allowedList[0] || "*"));

const cors = {
  "Access-Control-Allow-Origin": allowOriginHeader,
  "Vary": "Origin",
  "Access-Control-Allow-Methods": "POST, OPTIONS",
  "Access-Control-Allow-Headers": "Content-Type, Authorization"
};
```

## Environment Variables

### Required Variables
- `GEMINI_API_KEY` - Google Gemini API key
- `ALLOWED_ORIGIN` - Comma-separated list of allowed origins (optional, defaults to "*")

### Accessing Environment Variables
```javascript
const apiKey = process.env.GEMINI_API_KEY;
if (!apiKey) {
  return { 
    statusCode: 500, 
    headers: cors, 
    body: JSON.stringify({ error: "API key not configured" }) 
  };
}
```

## Request/Response Patterns

### Request Structure
Frontend sends:
```javascript
{
  endpoint: "gemini-1.5-flash:generateContent",
  body: {
    contents: [...],
    generationConfig: {...}
  }
}
```

### Response Structure
Always return:
```javascript
{
  statusCode: 200 | 400 | 500,
  headers: cors,
  body: JSON.stringify({ data, error })
}
```

## Error Handling

### Input Validation
```javascript
try {
  const { endpoint, body } = JSON.parse(event.body || "{}");
  if (!endpoint || !body) {
    return { 
      statusCode: 400, 
      headers: cors, 
      body: JSON.stringify({ error: "Missing endpoint or body" }) 
    };
  }
} catch (err) {
  return { 
    statusCode: 400, 
    headers: cors, 
    body: JSON.stringify({ error: "Invalid JSON" }) 
  };
}
```

### External API Errors
```javascript
const resp = await fetch(apiUrl, options);
const text = await resp.text();

if (!resp.ok) {
  return { 
    statusCode: resp.status, 
    headers: cors, 
    body: text || JSON.stringify({ error: "External API error" }) 
  };
}
```

### Generic Error Handling
```javascript
catch (err) {
  console.error("Function error:", err);
  return { 
    statusCode: 500, 
    headers: cors, 
    body: JSON.stringify({ error: err.message || "Server error" }) 
  };
}
```

## Security Best Practices

### Input Sanitization
- Always validate request structure
- Check for required fields
- Validate endpoint names (whitelist approach)
- Limit request body size

### Rate Limiting (if needed)
```javascript
// Example: Simple in-memory rate limiting with cleanup
const rateLimits = new Map();
let lastCleanup = Date.now();

function checkRateLimit(identifier) {
  const now = Date.now();
  
  // Periodic cleanup to prevent memory leak (every 5 minutes)
  if (now - lastCleanup > 300000) {
    rateLimits.clear();
    lastCleanup = now;
  }
  
  const limit = rateLimits.get(identifier) || [];
  const recent = limit.filter(time => now - time < 60000); // 1 minute window
  
  if (recent.length >= 10) { // 10 requests per minute
    return false;
  }
  
  recent.push(now);
  rateLimits.set(identifier, recent);
  return true;
}
```

### API Key Protection
- Never log API keys
- Never return API keys in responses
- Rotate keys periodically
- Use different keys for dev/staging/prod

## Testing Functions Locally

### Using Netlify CLI
```bash
# Install Netlify CLI
npm install -g netlify-cli

# Set environment variables in .env file
GEMINI_API_KEY=your_key_here

# Run function locally
netlify functions:serve

# Test with curl
curl -X POST http://localhost:9999/.netlify/functions/generate-plan \
  -H "Content-Type: application/json" \
  -d '{"endpoint":"gemini-1.5-flash:generateContent","body":{...}}'
```

## Deployment Checklist
When modifying functions:
- [ ] Test locally with Netlify CLI
- [ ] Verify CORS headers work with frontend
- [ ] Check environment variables are set in Netlify dashboard
- [ ] Test error scenarios (missing key, invalid input, API failures)
- [ ] Monitor function logs after deployment
- [ ] Verify cold start performance is acceptable
- [ ] Check response times meet requirements (<5s for normal requests)

## Common Issues & Solutions

### Cold Starts
- Functions may take 1-3 seconds on first invocation
- Keep functions small and focused
- Consider using Netlify's "keep-alive" for critical functions

### CORS Errors
- Ensure ALLOWED_ORIGIN environment variable is set correctly
- Check that frontend is using HTTPS (if required)
- Verify headers include "Vary: Origin" for caching

### Timeout Issues
- Netlify functions have 10-second timeout (can extend to 26s on paid plans)
- For long-running tasks, consider:
  - Webhooks for async processing
  - Splitting into multiple function calls
  - Background functions (paid feature)

## Function Structure Best Practices
- Keep functions under 200 lines
- One responsibility per function
- Extract shared utilities to separate files (if needed)
- Use descriptive function names
- Include comprehensive error handling

## Monitoring & Debugging
- Check Netlify function logs in dashboard
- Use `console.log()` for debugging (visible in logs)
- Monitor error rates and response times
- Set up alerts for function failures

## Performance Optimization
- Reuse connections when possible
- Cache external API responses (if appropriate)
- Minimize function bundle size
- Use async/await for cleaner code
- Avoid heavy dependencies
